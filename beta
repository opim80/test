local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

-- Services
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")

-- Constants
local MESH_ID_TARGET = "rbxassetid://12439777368"
local LocalPlayer = Players.LocalPlayer
local NODE_SPACING = 5 -- Larger spacing = faster calculation
local PLAYER_HEIGHT_CHECK = 6 -- Studs to check upward for walls

-- State Variables
local isInitialized = false 

-- Helper: Deep Find Devil Heart
local function findDevilHeart()
    local map = workspace:FindFirstChild("map")
    local rokyos = map and map:FindFirstChild("Rokyo")
    if rokyos then
        for _, object in ipairs(rokyos:GetChildren()) do
            if object:IsA("MeshPart") and object.MeshId == MESH_ID_TARGET then
                if object:FindFirstChildOfClass("PointLight") then return object end
            end
        end
    end
    return nil
end

-- Improved Collision Check: Deep Scans workspace.map
local function isAreaBlocked(pos)
    local map = workspace:FindFirstChild("map")
    if not map then return false end

    -- Define the check volume (Tall box for height safety)
    local halfSize = Vector3.new(2, PLAYER_HEIGHT_CHECK / 2, 2)
    local region = Region3.new(pos - halfSize, pos + halfSize)
    
    -- Check for parts in the region
    local parts = workspace:FindPartsInRegion3WithWhiteList(region, {map}, 100)

    for _, part in ipairs(parts) do
        if part.CanCollide then
            return true
        end
    end
    return false
end

-- Custom A* Pre-Calculation Logic
local function calculatePath(targetPos)
    local character = LocalPlayer.Character
    local root = character and character:FindFirstChild("HumanoidRootPart")
    local humanoid = character and character:FindFirstChild("Humanoid")
    if not root or not humanoid then return end

    local startPos = root.Position
    local pathPoints = {startPos}
    
    local currentPos = startPos
    local totalDist = (targetPos - startPos).Magnitude
    local steps = math.floor(totalDist / NODE_SPACING)

    Fluent:Notify({Title = "System", Content = "Scanning Map Geometry...", Duration = 3})

    for i = 1, steps do
        local nextStep = startPos + ((targetPos - startPos).Unit * (i * NODE_SPACING))
        
        -- If blocked, try to find a detour (Left/Right check)
        if isAreaBlocked(nextStep) then
            local foundDetour = false
            local detours = {Vector3.new(NODE_SPACING, 0, 0), Vector3.new(-NODE_SPACING, 0, 0), Vector3.new(0, 0, NODE_SPACING), Vector3.new(0, 0, -NODE_SPACING)}
            
            for _, offset in ipairs(detours) do
                if not isAreaBlocked(nextStep + offset) then
                    nextStep = nextStep + offset
                    foundDetour = true
                    break
                end
            end
            
            -- If no detour, the path stays at previous point to avoid walking into wall
            if not foundDetour then continue end
        end
        
        table.insert(pathPoints, nextStep)
    end
    table.insert(pathPoints, targetPos) -- Ensure final point is the heart

    -- Path Visualization
    local folder = workspace:FindFirstChild("PathVisuals") or Instance.new("Folder", workspace)
    folder.Name = "PathVisuals"
    folder:ClearAllChildren()

    for _, p in ipairs(pathPoints) do
        local b = Instance.new("Part", folder)
        b.Size, b.Anchored, b.CanCollide, b.Shape = Vector3.new(0.6, 0.6, 0.6), true, false, "Ball"
        b.Position, b.Color, b.Material = p, Color3.fromRGB(255, 255, 255), "Neon"
        b.Transparency = 0.5
    end

    -- Execute Movement
    for _, p in ipairs(pathPoints) do
        humanoid:MoveTo(p)
        local arrived = humanoid.MoveToFinished:Wait(2) -- Timeout after 2s per node
        if not arrived then humanoid.Jump = true end -- Small hop if stuck
    end
    
    folder:ClearAllChildren()
end

-- Create Window
local Window = Fluent:CreateWindow({
    Title = "Devil Heart Utility v5.5 (Deep Scan)",
    SubTitle = "Geometry-Aware Custom Movement",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true, 
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Tabs = {
    Automation = Window:AddTab({ Title = "Automation", Icon = "play" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

-- [[ AUTOMATION TAB ]]
Tabs.Automation:AddSection("Custom Movement (No Pathfinding Service)")

Tabs.Automation:AddButton({
    Title = "Scan & Walk to Heart",
    Description = "Checks all map children for collisions before moving.",
    Callback = function()
        local heart = findDevilHeart()
        if heart then
            calculatePath(heart.Position)
        else
            Fluent:Notify({Title = "Error", Content = "Devil Heart not found.", Duration = 3})
        end
    end
})

Tabs.Automation:AddParagraph({
    Title = "Geometry Scanning Info",
    Content = "This scan checks for any 'CanCollide' parts within 'workspace.map'. It accounts for height (6 studs) to prevent walking into walls."
})

-- [[ SETTINGS & INITIALIZATION ]]
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Window:SelectTab(1)
SaveManager:LoadAutoloadConfig()
task.wait(0.5)
isInitialized = true
